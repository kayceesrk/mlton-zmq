<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta name="robots" content="index,nofollow">



<title>Fold - MLton Standard ML Compiler (SML Compiler)</title>
<link rel="stylesheet" type="text/css" charset="iso-8859-1" media="all" href="common.css">
<link rel="stylesheet" type="text/css" charset="iso-8859-1" media="screen" href="screen.css">
<link rel="stylesheet" type="text/css" charset="iso-8859-1" media="print" href="print.css">


<link rel="Start" href="Home">


</head>

<body lang="en" dir="ltr">

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-833377-1";
urchinTracker();
</script>
<table bgcolor = lightblue cellspacing = 0 style = "border: 0px;" width = 100%>
  <tr>
    <td style = "
		border: 0px;
		color: darkblue; 
		font-size: 150%;
		text-align: left;">
      <a class = mltona href="Home">MLton MLTONWIKIVERSION</a>
    <td style = "
		border: 0px;
		font-size: 150%;
		text-align: center;
		width: 50%;">
      Fold
    <td style = "
		border: 0px;
		text-align: right;">
      <table cellspacing = 0 style = "border: 0px">
        <tr style = "vertical-align: middle;">
      </table>
  <tr style = "background-color: white;">
    <td colspan = 3
	style = "
		border: 0px;
		font-size:70%;
		text-align: right;">
      <a href = "Home">Home</a>
      &nbsp;<a href = "TitleIndex">Index</a>
      &nbsp;
</table>
<div id="content" lang="en" dir="ltr">
This page describes a technique that enables convenient syntax for a number of language features that are not explicitly supported by <a href="StandardML">Standard ML</a>, including: variable number of arguments, <a href="OptionalArguments">optional arguments and labeled arguments</a>,  <a href="ArrayLiteral">array and vector literals</a>, <a href="FunctionalRecordUpdate">functional record update</a>, and (seemingly) dependently typed functions like <a href="Printf">printf</a> and scanf. <p>
The key idea to <em>fold</em> is to define functions <tt>fold</tt>, <tt>step0</tt>, and <tt>$</tt> such that the following equation holds. 
</p>

<pre class=code>
fold (a, f) (step0 h1) (step0 h2) ... (step0 hn) $
= f (hn (... (h2 (h1 a))))
</PRE>
<p>
 
</p>
<p>
The name <tt>fold</tt> comes because this is like a traditional list fold, where <tt>a</tt> is the <em>base element</em>, and each <em>step function</em>,  <tt>step0&nbsp;hi</tt>, corresponds to one element of the list and does one step of the fold.  The name <tt>$</tt> is chosen to mean <em>end of arguments</em> from its common use in regular-expression syntax. 
</p>
<p>
Unlike the usual list fold in which the same function is used to step over each element in the list, this fold allows the step functions to be different from each other, and even to be of different types.  Also unlike the usual list fold, this fold includes a <em>finishing function</em>, <tt>f</tt>, that is applied to the result of the fold.  The presence of the finishing function may seem odd because there is no analogy in list fold.  However, the finishing function is essential; without it, there would be no way for the folder to perform an arbitrary computation after processing all the arguments.  The examples below will make this clear. 
</p>
<p>
The functions <tt>fold</tt>, <tt>step0</tt>, and <tt>$</tt> are easy to define. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">fun</FONT></B> $ (a, f) = f a
<B><FONT COLOR="#A020F0">fun</FONT></B> id x = x
<B><FONT COLOR="#0000FF">structure</FONT></B> Fold =
   <B><FONT COLOR="#0000FF">struct</FONT></B>
      <B><FONT COLOR="#A020F0">fun</FONT></B> fold (a, f) g = g (a, f)
      <B><FONT COLOR="#A020F0">fun</FONT></B> step0 h (a, f) = fold (h a, f)
   <B><FONT COLOR="#0000FF">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
We've placed <tt>fold</tt> and <tt>step0</tt> in the <tt>Fold</tt> structure but left <tt>$</tt> at the toplevel because it is convenient in code to always have <tt>$</tt> in scope.  We've also defined the identity function, <tt>id</tt>, at the toplevel since we use it so frequently. 
</p>
<p>
Plugging in the definitions, it is easy to verify the equation from above. 
<pre class=code>
fold (a, f) (step0 h1) (step0 h2) ... (step0 hn) $
= step0 h1 (a, f) (step0 h2) ... (step0 hn) $
= fold (h1 a, f) (step0 h2) ... (step0 hn) $
= step0 h2 (h1 a, f) ... (step0 hn) $
= fold (h2 (h1 a), f) ... (step0 hn) $
...
= fold (hn (... (h2 (h1 a))), f) $
= $ (hn (... (h2 (h1 a))), f)
= f (hn (... (h2 (h1 a))))
</PRE>
 
</p>
<h2 id="head-eb8e90f0113d0b7b2a22602f865ce3c364dd31e2">Example: variable number of arguments</h2>
<p>
The simplest example of fold is accepting a variable number of (curried) arguments.  We'll define a function <tt>f</tt> and argument <tt>a</tt> such that all of the following expressions are valid. 
</p>

<pre class=code>
f $
f a $
f a a $
f a a a $
f a a a ... a a a $ <I><FONT COLOR="#B22222">(* as many a's as we want *)</FONT></I>
</PRE>
<p>
 
</p>
<p>
Off-hand it may appear impossible that all of the above expressions are type correct SML -- how can a function <tt>f</tt> accept a variable number of curried arguments?  What could the type of <tt>f</tt> be? We'll have more to say later on how type checking works.  For now, once we have supplied the definitions below, you can check that the expressions are type correct by feeding them to your favorite SML implementation. 
</p>
<p>
It is simple to define <tt>f</tt> and <tt>a</tt>.  We define <tt>f</tt> as a folder whose base element is <tt>()</tt> and whose finish function does nothing.  We define <tt>a</tt> as the step function that does nothing. The only trickiness is that we must <a href="EtaExpansion">eta expand</a> the definition of <tt>f</tt> and <tt>a</tt> to work around the <a href="ValueRestriction">ValueRestriction</a>; we frequently use eta expansion for this purpose without mention. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> base = ()
<B><FONT COLOR="#A020F0">fun</FONT></B> finish () = ()
<B><FONT COLOR="#A020F0">fun</FONT></B> step () = ()
<B><FONT COLOR="#A020F0">val</FONT></B> f = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold (base, finish) z
<B><FONT COLOR="#A020F0">val</FONT></B> a = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 step z
</PRE>
<p>
 
</p>
<p>
One can easily apply the fold equation to verify by hand that <tt>f</tt> applied to any number of <tt>a</tt>'s evaluates to <tt>()</tt>. 
</p>

<pre class=code>
f a ... a $
= finish (step (... (step base)))
= finish (step (... ()))
...
= finish ()
= ()
</PRE>
<p>
 
</p>
<h2 id="head-677e9d12eacb1c50946b3f79103afd8ab8eea31e">Example: variable-argument sum</h2>
<p>
Let's look at an example that computes something: a variable-argument function <tt>sum</tt> and a stepper <tt>a</tt> such that 
</p>

<pre class=code>
sum (a i1) (a i2) ... (a im) $ = i1 + i2 + ... + im
</PRE>
<p>
 
</p>
<p>
The idea is simple -- the folder starts with a base accumulator of <tt>0</tt> and the stepper adds each element to the accumulator, <tt>s</tt>, which the folder simply returns at the end. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> sum = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold (<B><FONT COLOR="#5F9EA0">0</FONT></B>, <B><FONT COLOR="#A020F0">fn</FONT></B> s =&gt; s) z
<B><FONT COLOR="#A020F0">fun</FONT></B> a i = Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> s =&gt; i + s)
</PRE>
<p>
 
</p>
<p>
Using the fold equation, one can verify the following. 
</p>

<pre class=code>
sum (a <B><FONT COLOR="#5F9EA0">1</FONT></B>) (a <B><FONT COLOR="#5F9EA0">2</FONT></B>) (a <B><FONT COLOR="#5F9EA0">3</FONT></B>) $ = <B><FONT COLOR="#5F9EA0">6</FONT></B>
</PRE>
<p>
 
</p>
<h2 id="head-1480d125a98eea997802e10f81dd1a8a9384619b">Step1</h2>
<p>
It is sometimes syntactically convenient to omit the parentheses around the steps in a fold.  This is easily done by defining a new function, <tt>step1</tt>, as follows. 
</p>

<pre class=code>
<B><FONT COLOR="#0000FF">structure</FONT></B> Fold =
   <B><FONT COLOR="#0000FF">struct</FONT></B>
      <B><FONT COLOR="#0000FF">open</FONT></B> Fold
      <B><FONT COLOR="#A020F0">fun</FONT></B> step1 h (a, f) b = fold (h (b, a), f)
   <B><FONT COLOR="#0000FF">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
From the definition of <tt>step1</tt>, we have the following equivalence. 
</p>

<pre class=code>
fold (a, f) (step1 h) b
= step1 h (a, f) b
= fold (h (b, a), f)
</PRE>
<p>
 
</p>
<p>
Using the above equivalence, we can compute the following equation for <tt>step1</tt>. 
</p>

<pre class=code>
fold (a, f) (step1 h1) b1 (step1 h2) b2 ... (step1 hn) bn $
= fold (h1 (b1, a), f) (step1 h2) b2 ... (step1 hn) bn $
= fold (h2 (b2, h1 (b1, a)), f) ... (step1 hn) bn $
= fold (hn (bn, ... (h2 (b2, h1 (b1, a)))), f) $
= f (hn (bn, ... (h2 (b2, h1 (b1, a)))))
</PRE>
<p>
 
</p>
<p>
Here is an example using <tt>step1</tt> to define a variable-argument product function, <tt>prod</tt>, with a convenient syntax. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> prod = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold (<B><FONT COLOR="#5F9EA0">1</FONT></B>, <B><FONT COLOR="#A020F0">fn</FONT></B> p =&gt; p) z
<B><FONT COLOR="#A020F0">val</FONT></B> ` = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step1 (<B><FONT COLOR="#A020F0">fn</FONT></B> (i, p) =&gt; i * p) z
</PRE>
<p>
 
</p>
<p>
The functions <tt>prod</tt> and <tt>`</tt> satisfy the following equation. 
<pre class=code>
prod `i1 `i2 ... `im $ = i1 * i2 * ... * im
</PRE>
 
</p>
<p>
Note that in SML, <tt>`i1</tt> is two different tokens, <tt>`</tt> and <tt>i1</tt>.  We often use <tt>`</tt> for an instance of a <tt>step1</tt> function because of its syntactic unobtrusiveness and because no space is required to separate it from an alphanumeric token. 
</p>
<p>
Also note that there are no parenthesis around the steps.  That is, the following expression is not the same as the above one (in fact, it is not type correct). 
</p>

<pre class=code>
prod (`i1) (`i2) ... (`im) $
</PRE>
<p>
 
</p>
<h2 id="head-970703bc37877d12c60099a1b012e155e9057ca7">Example: list literals</h2>
<p>
SML already has a syntax for list literals, e.g. <tt>[w,&nbsp;x,&nbsp;y,&nbsp;z]</tt>. However, using fold, we can define our own syntax. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> list = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold ([], rev) z
<B><FONT COLOR="#A020F0">val</FONT></B> ` = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step1 (<B><FONT COLOR="#A020F0">op</FONT></B> ::) z
</PRE>
<p>
 
</p>
<p>
The idea is that the folder starts out with the empty list, the steps accumulate the elements into a list, and then the finishing function reverses the list at the end. 
</p>
<p>
With these definitions one can write a list like: 
</p>

<pre class=code>
list `w `x `y `z $
</PRE>
<p>
 
</p>
<p>
While the example is not practically useful, it does demonstrate the need for the finishing function to be incorporated in <tt>fold</tt>. Without a finishing function, every use of <tt>list</tt> would need to be wrapped in <tt>rev</tt>, as follows. 
</p>

<pre class=code>
rev (list `w `x `y `z $)
</PRE>
<p>
 
</p>
<p>
The finishing function allows us to incorporate the reversal into the definition of <tt>list</tt>, and to treat <tt>list</tt> as a truly variable argument function, performing an arbitrary computation after receiving all of its arguments. 
</p>
<p>
See <a href="ArrayLiteral">ArrayLiteral</a> for a similar use of <tt>fold</tt> that provides a syntax for array and vector literals, which are not built in to SML. 
</p>
<h2 id="head-a23a2fc1bc8d5112da93328461608221b9d8cb14">Fold right</h2>
<p>
Just as <tt>fold</tt> is analogous to a fold left, in which the functions are applied to the accumulator left-to-right, we can define a variant of <tt>fold</tt> that is analogous to a fold right, in which the functions are applied to the accumulator right-to-left.  That is, we can define functions <tt>foldr</tt> and <tt>step0</tt> such that the following equation holds. 
</p>

<pre class=code>
foldr (a, f) (step0 h1) (step0 h2) ... (step0 hn) $
= f (h1 (h2 (... (hn a))))
</PRE>
<p>
 
</p>
<p>
The implementation of fold right is easy, using fold.  The idea is for the fold to start with <tt>f</tt> and for each step to precompose the next <tt>hi</tt>.  Then, the finisher applies the composed function to the base value, <tt>a</tt>.  Here is the code. 
</p>

<pre class=code>
<B><FONT COLOR="#0000FF">structure</FONT></B> Foldr =
   <B><FONT COLOR="#0000FF">struct</FONT></B>
      <B><FONT COLOR="#A020F0">fun</FONT></B> foldr (a, f) = Fold.fold (f, <B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g a)
      <B><FONT COLOR="#A020F0">fun</FONT></B> step0 h = Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o h)
   <B><FONT COLOR="#0000FF">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
Verifying the fold-right equation is straightforward, using the fold-left equation. 
</p>

<pre class=code>
foldr (a, f) (Foldr.step0 h1) (Foldr.step0 h2) ... (Foldr.step0 hn) $
= fold (f, <B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g a) 
    (Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o h1))
    (Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o h2))
    ...
    (Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o hn)) $
= (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g a)
  ((<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o hn) (... ((<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o h2) ((<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o h1) f))))
= (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g a)
  ((<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o hn) (... ((<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o h2) (f o h1))))
= (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g a) ((<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g o hn) (... (f o h1 o h2)))
= (<B><FONT COLOR="#A020F0">fn</FONT></B> g =&gt; g a) (f o h1 o h2 o ... o hn)
= (f o h1 o h2 o ... o hn) a
= f (h1 (h2 (... (hn a))))
</PRE>
<p>
 
</p>
<p>
One can also define the fold-right analogue of <tt>step1</tt>. 
</p>

<pre class=code>
<B><FONT COLOR="#0000FF">structure</FONT></B> Foldr =
   <B><FONT COLOR="#0000FF">struct</FONT></B>
      <B><FONT COLOR="#0000FF">open</FONT></B> Foldr
      <B><FONT COLOR="#A020F0">fun</FONT></B> step1 h = Fold.step1 (<B><FONT COLOR="#A020F0">fn</FONT></B> (b, g) =&gt; g o (<B><FONT COLOR="#A020F0">fn</FONT></B> a =&gt; h (b, a)))
   <B><FONT COLOR="#0000FF">end</FONT></B>
</PRE>
<p>
 
</p>
<h2 id="head-ab8bc412c39f88e53289115eeb16ca0026e5b292">Example: list literals via fold right</h2>
<p>
Revisiting the list literal example from earlier, we can use fold right to define a syntax for list literals that doesn't do a reversal. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> list = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Foldr.foldr ([], <B><FONT COLOR="#A020F0">fn</FONT></B> l =&gt; l) z
<B><FONT COLOR="#A020F0">val</FONT></B> ` = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Foldr.step1 (<B><FONT COLOR="#A020F0">op</FONT></B> ::) z
</PRE>
<p>
 
</p>
<p>
As before, with these definitions, one can write a list like: 
</p>

<pre class=code>
list `w `x `y `z $
</PRE>
<p>
 
</p>
<p>
The difference between the fold-left and fold-right approaches is that the fold-right approach does not have to reverse the list at the end, since it accumulates the elements in the correct order.  In practice, MLton will simplify away all of the intermediate function composition, so the the fold-right approach will be more efficient. 
</p>
<h2 id="head-45726afdeece4355f73ffcb615f1d992001c692e">Mixing steppers</h2>
<p>
All of the examples so far have used the same step function throughout a fold.  This need not be the case.  For example, consider the following. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> n = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold (<B><FONT COLOR="#5F9EA0">0</FONT></B>, <B><FONT COLOR="#A020F0">fn</FONT></B> i =&gt; i) z
<B><FONT COLOR="#A020F0">val</FONT></B> I = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> i =&gt; i * <B><FONT COLOR="#5F9EA0">2</FONT></B>) z
<B><FONT COLOR="#A020F0">val</FONT></B> O = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> i =&gt; i * <B><FONT COLOR="#5F9EA0">2</FONT></B> + <B><FONT COLOR="#5F9EA0">1</FONT></B>) z
</PRE>
<p>
 
</p>
<p>
Here we have one folder, <tt>n</tt>, that can be used with two different steppers, <tt>I</tt> and <tt>O</tt>.  By using the fold equation, one can verify the following equations. 
</p>

<pre class=code>
n O $ = <B><FONT COLOR="#5F9EA0">0</FONT></B>
n I $ = <B><FONT COLOR="#5F9EA0">1</FONT></B>
n I O $ = <B><FONT COLOR="#5F9EA0">2</FONT></B>
n I O I $ = <B><FONT COLOR="#5F9EA0">5</FONT></B>
n I I I O $ = <B><FONT COLOR="#5F9EA0">14</FONT></B>
</PRE>
<p>
 
</p>
<p>
That is, we've defined a syntax for writing binary integer constants. 
</p>
<p>
Not only can one use different instances of <tt>step0</tt> in the same fold, one can also intermix uses of <tt>step0</tt> and <tt>step1</tt>.  For example, consider the following. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> n = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold (<B><FONT COLOR="#5F9EA0">0</FONT></B>, <B><FONT COLOR="#A020F0">fn</FONT></B> i =&gt; i) z
<B><FONT COLOR="#A020F0">val</FONT></B> O = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> i =&gt; n * <B><FONT COLOR="#5F9EA0">8</FONT></B>) z
<B><FONT COLOR="#A020F0">val</FONT></B> ` = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step1 (<B><FONT COLOR="#A020F0">fn</FONT></B> (i, n) =&gt; n * <B><FONT COLOR="#5F9EA0">8</FONT></B> + i) z
</PRE>
<p>
 
</p>
<p>
Using the straightforward generalization of the fold equation to mixed steppers, one can verify the following equations. 
</p>

<pre class=code>
n <B><FONT COLOR="#5F9EA0">0</FONT></B> $ = <B><FONT COLOR="#5F9EA0">0</FONT></B>
n `<B><FONT COLOR="#5F9EA0">3</FONT></B> O $ = <B><FONT COLOR="#5F9EA0">24</FONT></B>
n `<B><FONT COLOR="#5F9EA0">1</FONT></B> O `<B><FONT COLOR="#5F9EA0">7</FONT></B> $ = <B><FONT COLOR="#5F9EA0">71</FONT></B>
</PRE>
<p>
 
</p>
<p>
That is, we've defined a syntax for writing octal integer constants, with a special syntax, <tt>O</tt>, for the zero digit (admittedly contrived, since one could just write <tt>`0</tt> instead of <tt>O</tt>). 
</p>
<p>
See <a href="NumericLiteral">NumericLiteral</a> for a practical extension of this approach that supports numeric constants in any base and of any type. 
</p>
<h2 id="head-c9f72c00a8519db78dbb19512887495769c7358d">(Seemingly) dependent types</h2>
<p>
A normal list fold always returns the same type no matter what elements are in the list or how long the list is.  Variable-argument fold is more powerful, because the result type can vary based both on the arguments that are passed and on their number.  This can provide the illusion of dependent types. 
</p>
<p>
For example, consider the following. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> f = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold ((), id) z
<B><FONT COLOR="#A020F0">val</FONT></B> a = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; <B><FONT COLOR="#BC8F8F">&quot;hello&quot;</FONT></B>) z
<B><FONT COLOR="#A020F0">val</FONT></B> b = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; <B><FONT COLOR="#5F9EA0">13</FONT></B>) z
<B><FONT COLOR="#A020F0">val</FONT></B> c = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; (<B><FONT COLOR="#5F9EA0">1</FONT></B>, <B><FONT COLOR="#5F9EA0">2</FONT></B>)) z
</PRE>
<p>
 
</p>
<p>
Using the fold equation, one can verify the following equations. 
</p>

<pre class=code>
f a $ = <B><FONT COLOR="#BC8F8F">&quot;hello&quot;</FONT></B>: string
f b $ = <B><FONT COLOR="#5F9EA0">13</FONT></B>: int
f c $ = (<B><FONT COLOR="#5F9EA0">1</FONT></B>, <B><FONT COLOR="#5F9EA0">2</FONT></B>): int * int
</PRE>
<p>
 
</p>
<p>
That is, <tt>f</tt> returns a value of a different type depending on whether it is applied to argument <tt>a</tt>, argument <tt>b</tt>, or argument <tt>c</tt>. 
</p>
<p>
The following example shows how the type of a fold can depend on the number of arguments. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> grow = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold ([], <B><FONT COLOR="#A020F0">fn</FONT></B> l =&gt; l) z
<B><FONT COLOR="#A020F0">val</FONT></B> a = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> x =&gt; [x]) z
</PRE>
<p>
 
</p>
<p>
Using the fold equation, one can verify the following equations. 
</p>

<pre class=code>
grow $ = []: 'a list
grow a $ = [[]]: 'a list list
grow a a $ = [[[]]]: 'a list list list
</PRE>
<p>
 
</p>
<p>
Clearly, the result type of a call to the variable argument <tt>grow</tt> function depends on the number of arguments that are passed. 
</p>
<p>
As a reminder, this is well-typed SML.  You can check it out in any implementation. 
</p>
<h2 id="head-dee978912295db9e76200c094e45424c3e4d4b7c">(Seemingly) dependently-typed functional results</h2>
<p>
Fold is especially useful when it returns a curried function whose arity depends on the number of arguments.  For example, consider the following. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> makeSum = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold (id, <B><FONT COLOR="#A020F0">fn</FONT></B> f =&gt; f <B><FONT COLOR="#5F9EA0">0</FONT></B>) z
<B><FONT COLOR="#A020F0">val</FONT></B> I = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> f =&gt; <B><FONT COLOR="#A020F0">fn</FONT></B> i =&gt; <B><FONT COLOR="#A020F0">fn</FONT></B> x =&gt; f (x + i)) z
</PRE>
<p>
 
</p>
<p>
The <tt>makeSum</tt> folder constructs a function whose arity depends on the number of <tt>I</tt> arguments and that adds together all of its arguments.  For example,  <tt>makeSum&nbsp;I&nbsp;$</tt> is of type <tt>int&nbsp;-&gt;&nbsp;int</tt> and <tt>makeSum&nbsp;I&nbsp;I&nbsp;$</tt> is of type <tt>int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int</tt>. 
</p>
<p>
One can use the fold equation to verify that the <tt>makeSum</tt> works correctly.  For example, one can easily check by hand the following equations. 
<pre class=code>
makeSum I $ <B><FONT COLOR="#5F9EA0">1</FONT></B> = <B><FONT COLOR="#5F9EA0">1</FONT></B>
makeSum I I $ <B><FONT COLOR="#5F9EA0">1</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B> = <B><FONT COLOR="#5F9EA0">3</FONT></B>
makeSum I I I $ <B><FONT COLOR="#5F9EA0">1</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B> = <B><FONT COLOR="#5F9EA0">6</FONT></B>
</PRE>
 
</p>
<p>
Returning a function becomes especially interesting when there are steppers of different types.  For example, the following <tt>makeSum</tt> folder constructs functions that sum integers and reals. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> makeSum = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Foldr.foldr (id, <B><FONT COLOR="#A020F0">fn</FONT></B> f =&gt; f <B><FONT COLOR="#5F9EA0">0.0</FONT></B>) z
<B><FONT COLOR="#A020F0">val</FONT></B> I = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Foldr.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> f =&gt; <B><FONT COLOR="#A020F0">fn</FONT></B> x =&gt; <B><FONT COLOR="#A020F0">fn</FONT></B> i =&gt; f (x + real i)) z
<B><FONT COLOR="#A020F0">val</FONT></B> R = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Foldr.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> f =&gt; <B><FONT COLOR="#A020F0">fn</FONT></B> x: real =&gt; <B><FONT COLOR="#A020F0">fn</FONT></B> r =&gt; f (x + r)) z
</PRE>
<p>
 
</p>
<p>
With these definitions, <tt>makeSum&nbsp;I&nbsp;R&nbsp;$</tt> is of type  <tt>int&nbsp;-&gt;&nbsp;real&nbsp;-&gt;&nbsp;real</tt> and <tt>makeSum&nbsp;R&nbsp;I&nbsp;I&nbsp;$</tt> is of type <tt>real&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;real</tt>.  One can use the foldr equation to check the following equations.  
</p>

<pre class=code>
makeSum I $ <B><FONT COLOR="#5F9EA0">1</FONT></B> = <B><FONT COLOR="#5F9EA0">1.0</FONT></B>
makeSum I R $ <B><FONT COLOR="#5F9EA0">1</FONT></B> <B><FONT COLOR="#5F9EA0">2.5</FONT></B> = <B><FONT COLOR="#5F9EA0">3.5</FONT></B>
makeSum R I I $ <B><FONT COLOR="#5F9EA0">1.5</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B> = <B><FONT COLOR="#5F9EA0">6.5</FONT></B>
</PRE>
<p>
 
</p>
<p>
We used <tt>foldr</tt> instead of <tt>fold</tt> for this so that the order in which the specifiers <tt>I</tt> and <tt>R</tt> appear is the same as the order in which the arguments appear.  Had we used <tt>fold</tt>, things would have been reversed. 
</p>
<p>
An extension of this idea is sufficient to define <a href="Printf">Printf</a>-like functions in SML. 
</p>
<h2 id="head-82cd031b8d5489f5a7ab5198fd65d34f16cada72">An idiom for combining steps</h2>
<p>
It is sometimes useful to combine a number of steps together and name them as a single step.  As a simple example, suppose that one often sees an integer follower by a real in the <tt>makeSum</tt> example above. One can define a new <em>compound step</em> <tt>IR</tt> as follows. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> IR = <B><FONT COLOR="#A020F0">fn</FONT></B> u =&gt; Fold.fold u I R
</PRE>
<p>
 
</p>
<p>
With this definition in place, one can verify the following. 
</p>

<pre class=code>
makeSum IR IR $ <B><FONT COLOR="#5F9EA0">1</FONT></B> <B><FONT COLOR="#5F9EA0">2.2</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B> <B><FONT COLOR="#5F9EA0">4.4</FONT></B> = <B><FONT COLOR="#5F9EA0">10.6</FONT></B>
</PRE>
<p>
 
</p>
<p>
In general, one can combine steps <tt>s1</tt>, <tt>s2</tt>, ... <tt>sn</tt> as 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">fn</FONT></B> u =&gt; Fold.fold u s1 s2 ... sn
</PRE>
<p>
 
</p>
<p>
The following calculation shows why a compound step behaves as the composition of its constituent steps. 
</p>

<pre class=code>
fold u (<B><FONT COLOR="#A020F0">fn</FONT></B> u =&gt; fold u s1 s2 ... sn)
= (<B><FONT COLOR="#A020F0">fn</FONT></B> u =&gt; fold u s1 s2 ... sn) u
= fold u s1 s2 ... sn
</PRE>
<p>
 
</p>
<h2 id="head-ffb763362aa4b1ab8da43465778c25a2676ba059">Post composition</h2>
<p>
Suppose we already have a function defined via fold,  <tt>w&nbsp;=&nbsp;fold&nbsp;(a,&nbsp;f)</tt>, and we would like to construct a new fold function that is like <tt>w</tt>, but applies <tt>g</tt> to the result produced by <tt>w</tt>.  This is similar to function composition, but we can't just do <tt>g&nbsp;o&nbsp;w</tt>, because we don't want to use <tt>g</tt> until <tt>w</tt> has been applied to all of its arguments and received the end-of-arguments terminator <tt>$</tt>. 
</p>
<p>
More precisely, we want to define a post-composition function <tt>post</tt> that satisfies the following equation. 
</p>

<pre class=code>
post (w, g) s1 ... sn $ = g (w s1 ... sn $)
</PRE>
<p>
 
</p>
<p>
Here is the definition of <tt>post</tt>. 
</p>

<pre class=code>
<B><FONT COLOR="#0000FF">structure</FONT></B> Fold =
   <B><FONT COLOR="#0000FF">struct</FONT></B>
      <B><FONT COLOR="#0000FF">open</FONT></B> Fold
      <B><FONT COLOR="#A020F0">fun</FONT></B> post (w, g) s = w (<B><FONT COLOR="#A020F0">fn</FONT></B> (a, h) =&gt; s (a, g o h))
   <B><FONT COLOR="#0000FF">end</FONT></B>  
</PRE>
<p>
 
</p>
<p>
The following calculations show that <tt>post</tt> satisfies the desired equation, where <tt>w&nbsp;=&nbsp;fold&nbsp;(a,&nbsp;f)</tt>. 
</p>

<pre class=code>
post (w, g) s
= w (<B><FONT COLOR="#A020F0">fn</FONT></B> (a, h) =&gt; s (a, g o h))
= fold (a, f) (<B><FONT COLOR="#A020F0">fn</FONT></B> (a, h) =&gt; s (a, g o h))
= (<B><FONT COLOR="#A020F0">fn</FONT></B> (a, h) =&gt; s (a, g o h)) (a, f)
= s (a, g o f)
= fold (a, g o f) s
</PRE>
<p>
 
</p>
<p>
Now, suppose <tt>si&nbsp;=&nbsp;step0&nbsp;hi</tt> for <tt>i</tt> from <tt>1</tt> to <tt>n</tt>. 
</p>

<pre class=code>
post (w, g) s1 s2 ... sn $
= fold (a, g o f) s1 s2 ... sn $
= (g o f) (hn (... (h1 a)))
= g (f (hn (... (h1 a))))
= g (fold (a, f) s1 ... sn $)
= g (w s1 ... sn $)
</PRE>
<p>
 
</p>
<p>
For a practical example of post composition, see <a href="ArrayLiteral">ArrayLiteral</a>. 
</p>
<h2 id="head-efd0976a0ad531b6453a3782b50f0f3ff5363b1e">Lift</h2>
<p>
We now define a peculiar-looking function, <tt>lift0</tt>, that is, equationally speaking, equivalent to the identity function on a step function. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">fun</FONT></B> lift0 s (a, f) = fold (fold (a, id) s $, f)
</PRE>
<p>
 
</p>
<p>
Using the definitions, we can prove the following equation. 
</p>

<pre class=code>
fold (a, f) (lift0 (step0 h)) = fold (a, f) (step0 h)
</PRE>
<p>
 
</p>
<p>
Here is the proof. 
</p>

<pre class=code>
fold (a, f) (lift0 (step0 h))
= lift0 (step0 h) (a, f)
= fold (fold (a, id) (step0 h) $, f)
= fold (step0 h (a, id) $, f)
= fold (fold (h a, id) $, f)
= fold ($ (h a, id), f)
= fold (id (h a), f)
= fold (h a, f)
= step0 h (a, f)
= fold (a, f) (step0 h)
</PRE>
<p>
 
</p>
<p>
If <tt>lift0</tt> is the identity, then why even define it?  The answer lies in the typing of fold expressions, which we have, until now, left unexplained. 
</p>
<h2 id="head-5614fd83d7c12176ea9d23d0a9a55af15cb1297f">Typing</h2>
<p>
Perhaps the most surprising aspect of fold is that it can be checked by the SML type system.  The types involved in fold expressions are complex; fortunately type inference is able to deduce them. Nevertheless, it is instructive to study the types of fold functions and steppers.  More importantly, it is essential to understand the typing aspects of fold in order to write down signatures of functions defined using fold and step. 
</p>
<p>
Here is the <tt>FOLD</tt> signature, and a recapitulation of the entire <tt>Fold</tt> structure, with additional type annotations. 
</p>

<pre class=code>
<B><FONT COLOR="#0000FF">signature</FONT></B> FOLD =
   <B><FONT COLOR="#0000FF">sig</FONT></B>
      <B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) step </FONT></B>=<B><FONT COLOR="#228B22"> 'a * ('b -&gt; 'c) -&gt; 'd
      </FONT></B><B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) t </FONT></B>=<B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) step -&gt; 'd
      </FONT></B><B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a1, 'a2, 'b, 'c, 'd) step0 </FONT></B>=<B><FONT COLOR="#228B22">
         ('a1, 'b, 'c, ('a2, 'b, 'c, 'd) t) step
      </FONT></B><B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a11, 'a12, 'a2, 'b, 'c, 'd) step1 </FONT></B>=<B><FONT COLOR="#228B22">
         ('a12, 'b, 'c, 'a11 -&gt; ('a2, 'b, 'c, 'd) t) step
         
      </FONT></B><B><FONT COLOR="#A020F0">val</FONT></B> fold: 'a * ('b -&gt; 'c) -&gt; ('a, 'b, 'c, 'd) t
      <B><FONT COLOR="#A020F0">val</FONT></B> lift0: ('a1, 'a2, 'a2, 'a2, 'a2) step0
                 -&gt; ('a1, 'a2, 'b, 'c, 'd) step0
      <B><FONT COLOR="#A020F0">val</FONT></B> post: ('a, 'b, 'c1, 'd) t * ('c1 -&gt; 'c2)
                -&gt; ('a, 'b, 'c2, 'd) t
      <B><FONT COLOR="#A020F0">val</FONT></B> step0: ('a1 -&gt; 'a2) -&gt; ('a1, 'a2, 'b, 'c, 'd) step0
      <B><FONT COLOR="#A020F0">val</FONT></B> step1: ('a11 * 'a12 -&gt; 'a2)
                 -&gt; ('a11, 'a12, 'a2, 'b, 'c, 'd) step1
   <B><FONT COLOR="#0000FF">end</FONT></B>

<B><FONT COLOR="#0000FF">structure</FONT></B> Fold:&gt; FOLD =
   <B><FONT COLOR="#0000FF">struct</FONT></B>
      <B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) step </FONT></B>=<B><FONT COLOR="#228B22"> 'a * ('b -&gt; 'c) -&gt; 'd

      </FONT></B><B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) t </FONT></B>=<B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) step -&gt; 'd

      </FONT></B><B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a1, 'a2, 'b, 'c, 'd) step0 </FONT></B>=<B><FONT COLOR="#228B22">
         ('a1, 'b, 'c, ('a2, 'b, 'c, 'd) t) step

      </FONT></B><B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a11, 'a12, 'a2, 'b, 'c, 'd) step1 </FONT></B>=<B><FONT COLOR="#228B22">
         ('a12, 'b, 'c, 'a11 -&gt; ('a2, 'b, 'c, 'd) t) step

      </FONT></B><B><FONT COLOR="#A020F0">fun</FONT></B> fold (a: 'a, f: 'b -&gt; 'c)
               (g: ('a, 'b, 'c, 'd) step): 'd =
         g (a, f)

      <B><FONT COLOR="#A020F0">fun</FONT></B> step0 (h: 'a1 -&gt; 'a2)
                (a1: 'a1, f: 'b -&gt; 'c): ('a2, 'b, 'c, 'd) t =
         fold (h a1, f)

      <B><FONT COLOR="#A020F0">fun</FONT></B> step1 (h: 'a11 * 'a12 -&gt; 'a2)
                (a12: 'a12, f: 'b -&gt; 'c)
                (a11: 'a11): ('a2, 'b, 'c, 'd) t =
         fold (h (a11, a12), f)

      <B><FONT COLOR="#A020F0">fun</FONT></B> lift0 (s: ('a1, 'a2, 'a2, 'a2, 'a2) step0)
                (a: 'a1, f: 'b -&gt; 'c): ('a2, 'b, 'c, 'd) t =
         fold (fold (a, id) s $, f)
            
      <B><FONT COLOR="#A020F0">fun</FONT></B> post (w: ('a, 'b, 'c1, 'd) t,
                g: 'c1 -&gt; 'c2)
               (s: ('a, 'b, 'c2, 'd) step): 'd =
         w (<B><FONT COLOR="#A020F0">fn</FONT></B> (a, h) =&gt; s (a, g o h))
   <B><FONT COLOR="#0000FF">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
That's a lot to swallow, so let's walk through it one step at a time. First, we have the definition of type <tt>Fold.step</tt>. 
<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) step </FONT></B>=<B><FONT COLOR="#228B22"> 'a * ('b -&gt; 'c) -&gt; 'd
</FONT></B></PRE>
 
</p>
<p>
As a fold proceeds over its arguments, it maintains two things: the accumulator, of type <tt>'a</tt>, and the finishing function, of type <tt>'b&nbsp;-&gt;&nbsp;'c</tt>.  Each step in the fold is a function that takes those two pieces (i.e. <tt>'a&nbsp;*&nbsp;('b&nbsp;-&gt;&nbsp;'c)</tt> and does something to them (i.e. produces <tt>'d</tt>).  The result type of the step is completely left open to be filled in by type inference, as it is an arrow type that is capable of consuming the rest of the arguments to the fold. 
</p>
<p>
A folder, of type <tt>Fold.t</tt>, is a function that consumes a single step.   
<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) t </FONT></B>=<B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) step -&gt; 'd
</FONT></B></PRE>
 
</p>
<p>
Expanding out the type, we have: 
<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c, 'd) t </FONT></B>=<B><FONT COLOR="#228B22"> ('a * ('b -&gt; 'c) -&gt; 'd) -&gt; 'd
</FONT></B></PRE>
 
</p>
<p>
This shows that the only thing a folder does is to hand its accumulator (<tt>'a</tt>) and finisher (<tt>'b&nbsp;-&gt;&nbsp;'c</tt>) to the next step (<tt>'a&nbsp;*&nbsp;('b&nbsp;-&gt;&nbsp;'c)&nbsp;-&gt;&nbsp;'d</tt>).  If SML had <a href="FirstClassPolymorphism">first-class polymorphism</a>, we would write the fold type as follows. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a, 'b, 'c) t </FONT></B>=<B><FONT COLOR="#228B22"> Forall 'd. ('a, 'b, 'c, 'd) step -&gt; 'd
</FONT></B></PRE>
<p>
 
</p>
<p>
This type definition shows that a folder had nothing to do with the rest of the fold, it only deals with the next step. 
</p>
<p>
We now can understand the type of <tt>fold</tt>, which takes the initial value of the accumulator and the finishing function, and constructs a folder, i.e. a function awaiting the next step. 
<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> fold: 'a * ('b -&gt; 'c) -&gt; ('a, 'b, 'c, 'd) t
<B><FONT COLOR="#A020F0">fun</FONT></B> fold (a: 'a, f: 'b -&gt; 'c)
         (g: ('a, 'b, 'c, 'd) step): 'd =
   g (a, f)
</PRE>
 
</p>
<p>
Continuing on, we have the type of step functions. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a1, 'a2, 'b, 'c, 'd) step0 </FONT></B>=<B><FONT COLOR="#228B22"> 
   ('a1, 'b, 'c, ('a2, 'b, 'c, 'd) t) step
</FONT></B></PRE>
<p>
 
</p>
<p>
Expanding out the type a bit gives: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a1, 'a2, 'b, 'c, 'd) step0 </FONT></B>=<B><FONT COLOR="#228B22"> 
   'a1 * ('b -&gt; 'c) -&gt; ('a2, 'b, 'c, 'd) t
</FONT></B></PRE>
<p>
 
</p>
<p>
So, a step function takes the accumulator (<tt>'a1</tt>) and finishing function (<tt>'b&nbsp;-&gt;&nbsp;'c</tt>), which will be passed to it by the previous folder, and transforms them to a new folder.  This new folder has a new accumulator (<tt>'a2</tt>) and the same finishing function. 
</p>
<p>
Again, imagining that SML had <a href="FirstClassPolymorphism">first-class polymorphism</a> makes the type clearer. 
<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a1, 'a2) step0 </FONT></B>=<B><FONT COLOR="#228B22"> 
   Forall ('b, 'c). ('a1, 'b, 'c, ('a2, 'b, 'c) t) step
</FONT></B></PRE>
 
</p>
<p>
Thus, in essence, a <tt>step0</tt> function is a wrapper around a function of type <tt>'a1&nbsp;-&gt;&nbsp;'a2</tt>, which is exactly what the definition of <tt>step0</tt> does. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> step0: ('a1 -&gt; 'a2) -&gt; ('a1, 'a2, 'b, 'c, 'd) step0
<B><FONT COLOR="#A020F0">fun</FONT></B> step0 (h: 'a1 -&gt; 'a2)
          (a1: 'a1, f: 'b -&gt; 'c): ('a2, 'b, 'c, 'd) t =
   fold (h a1, f)
</PRE>
<p>
 
</p>
<p>
It is not much beyond <tt>step0</tt> to understand <tt>step1</tt>. 
<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a11, 'a12, 'a2, 'b, 'c, 'd) step1 </FONT></B>=<B><FONT COLOR="#228B22">
   ('a12, 'b, 'c, 'a11 -&gt; ('a2, 'b, 'c, 'd) t) step
</FONT></B></PRE>
 
</p>
<p>
A <tt>step1</tt> function takes the accumulator (<tt>'a12</tt>) and finisher (<tt>'b&nbsp;-&gt;&nbsp;'c</tt>) passed to it by the previous folder and transforms them into a function that consumes the next argument (<tt>'a11</tt>) and produces a folder that will continue the fold with a new accumulator (<tt>'a2</tt>) and the same finisher. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">fun</FONT></B> step1 (h: 'a11 * 'a12 -&gt; 'a2)
          (a12: 'a12, f: 'b -&gt; 'c)
          (a11: 'a11): ('a2, 'b, 'c, 'd) t =
   fold (h (a11, a12), f)
</PRE>
<p>
 
</p>
<p>
With <a href="FirstClassPolymorphism">first-class polymorphism</a>, a <tt>step1</tt> function is more clearly seen as a wrapper around a binary function of type  <tt>'a11&nbsp;*&nbsp;'a12&nbsp;-&gt;&nbsp;'a2</tt>. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ('a11, 'a12, 'a2) step1 </FONT></B>=<B><FONT COLOR="#228B22">
   Forall ('b, 'c). ('a12, 'b, 'c, 'a11 -&gt; ('a2, 'b, 'c) t) step
</FONT></B></PRE>
<p>
 
</p>
<p>
The type of <tt>post</tt> is clear: it takes a folder with a finishing function that produces type <tt>'c1</tt>, and a function of type  <tt>'c1&nbsp;-&gt;&nbsp;'c2</tt> to postcompose onto the folder.  It returns a new folder with a finishing function that produces type <tt>'c2</tt>. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> post: ('a, 'b, 'c1, 'd) t * ('c1 -&gt; 'c2)
          -&gt; ('a, 'b, 'c2, 'd) t
<B><FONT COLOR="#A020F0">fun</FONT></B> post (w: ('a, 'b, 'c1, 'd) t,
          g: 'c1 -&gt; 'c2)
         (s: ('a, 'b, 'c2, 'd) step): 'd =
   w (<B><FONT COLOR="#A020F0">fn</FONT></B> (a, h) =&gt; s (a, g o h))
</PRE>
<p>
 
</p>
<p>
We will return to <tt>lift0</tt> after an example. 
</p>
<h2 id="head-e13dce34fe568689c1beb05e209023d50ff036df">An example typing</h2>
<p>
Let's type check our simplest example, a variable-argument fold. Recall that we have a folder <tt>f</tt> and a stepper <tt>a</tt> defined as follows. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> f = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold ((), <B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; ()) z
<B><FONT COLOR="#A020F0">val</FONT></B> a = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; ()) z
</PRE>
<p>
 
</p>
<p>
Since the accumulator and finisher are uninteresting, we'll use some abbreviations to simplify things. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> 'd step </FONT></B>=<B><FONT COLOR="#228B22"> (unit, unit, unit, 'd) Fold.step
</FONT></B><B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> 'd fold </FONT></B>=<B><FONT COLOR="#228B22"> 'd step -&gt; 'd
</FONT></B></PRE>
<p>
 
</p>
<p>
With these abbreviations, <tt>f</tt> and <tt>a</tt> have the following polymorphic types. 
<pre class=code>
f: 'd fold
a: 'd step
</PRE>
 
</p>
<p>
Suppose we want to type check  
<pre class=code>
f a a a $: unit
</PRE>
 As a reminder, the fully parenthesized expression is  
<pre class=code>
((((f a) a) a) a) $
</PRE>
 The observation that we will use repeatedly is that for any type <tt>z</tt>, if <tt>f:&nbsp;z&nbsp;fold</tt> and <tt>s:&nbsp;z&nbsp;step</tt>, then <tt>f&nbsp;s:&nbsp;z</tt>. So, if we want  
<pre class=code>
(f a a a) $: unit
</PRE>
  then we must have  
<pre class=code>
f a a a: unit fold
$: unit step
</PRE>
 Applying the observation again, we must have  
<pre class=code>
f a a: unit fold fold
a: unit fold step
</PRE>
 
</p>
<p>
Applying the observation two more times leads to the following type derivation. 
</p>

<pre class=code>
f: unit fold fold fold fold  a: unit fold fold fold step
f a: unit fold fold fold     a: unit fold fold step
f a a: unit fold fold        a: unit fold step
f a a a: unit fold           $: unit step
f a a a $: unit
</PRE>
<p>
 
</p>
<p>
So, each application is a fold that consumes the next step, producing a fold of one smaller type. 
</p>
<p>
One can expand some of the type definitions in <tt>f</tt> to see that it is indeed a function that takes four curried arguments, each one a step function. 
</p>

<pre class=code>
f: unit fold fold fold step 
   -&gt; unit fold fold step
   -&gt; unit fold step
   -&gt; unit step
   -&gt; unit
</PRE>
<p>
 
</p>
<p>
This example shows why we must eta expand uses of <tt>fold</tt> and <tt>step0</tt> to work around the value restriction and make folders and steppers polymorphic.  The type of a fold function like <tt>f</tt> depends on the number of arguments, and so will vary from use to use. Similarly, each occurrence of an argument like <tt>a</tt> has a different type, depending on the number of remaining arguments. 
</p>
<p>
This example also shows that the type of a folder, when fully expanded, is exponential in the number of arguments: there are as many nested occurrences of the <tt>fold</tt> type constructor as there are arguments, and each occurrence duplicates its type argument.  One can observe this exponential behavior in a type checker that doesn't share enough of the representation of types (e.g. one that represents types as trees rather than directed acyclic graphs). 
</p>
<p>
Generalizing this type derivation to uses of fold where the accumulator and finisher are more interesting is straightforward.  One simply includes the type of the accumulator, which may change, for each step, and the type of the finisher, which doesn't change from step to step. 
</p>
<h2 id="head-f1a127be542fc4a883aa37976ca48c19faf93b98">Typing lift</h2>
<p>
The lack of <a href="FirstClassPolymorphism">first-class polymorphism</a> in SML causes problems if one wants to use a step in a first-class way.  Consider the following <tt>double</tt> function, which takes a step, <tt>s</tt>, and produces a composite step that does <tt>s</tt> twice. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">fun</FONT></B> double s = <B><FONT COLOR="#A020F0">fn</FONT></B> u =&gt; Fold.fold u s s
</PRE>
<p>
 
</p>
<p>
The definition of <tt>double</tt> is not type correct.  The problem is that the type of a step depends on the number of remaining arguments but that the parameter <tt>s</tt> is not polymorphic, and so can not be used in two different positions. 
</p>
<p>
Fortunately, we can define a function, <tt>lift0</tt>, that takes a monotyped step function and <em>lifts</em> it into a polymorphic step function.   This is apparent in the type of <tt>lift0</tt>. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> lift0: ('a1, 'a2, 'a2, 'a2, 'a2) step0
           -&gt; ('a1, 'a2, 'b, 'c, 'd) step0
<B><FONT COLOR="#A020F0">fun</FONT></B> lift0 (s: ('a1, 'a2, 'a2, 'a2, 'a2) step0)
          (a: 'a1, f: 'b -&gt; 'c): ('a2, 'b, 'c, 'd) t =
   fold (fold (a, id) s $, f)
</PRE>
<p>
 
</p>
<p>
The following definition of <tt>double</tt> uses <tt>lift0</tt>, appropriately eta wrapped, to fix the problem. 
<pre class=code>
<B><FONT COLOR="#A020F0">fun</FONT></B> double s =
   <B><FONT COLOR="#A020F0">let</FONT></B>
      <B><FONT COLOR="#A020F0">val</FONT></B> s = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.lift0 s z
   <B><FONT COLOR="#A020F0">in</FONT></B>
      <B><FONT COLOR="#A020F0">fn</FONT></B> u =&gt; Fold.fold u s s
   <B><FONT COLOR="#A020F0">end</FONT></B>
</PRE>
 
</p>
<p>
With that definition of <tt>double</tt> in place, we can use it as in the following example. 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> f = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold ((), <B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; ()) z
<B><FONT COLOR="#A020F0">val</FONT></B> a = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; ()) z
<B><FONT COLOR="#A020F0">val</FONT></B> a2 = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; double a z
<B><FONT COLOR="#A020F0">val</FONT></B> () = f a a2 a a2 $
</PRE>
<p>
 
</p>
<p>
Of course, we must eta wrap the call <tt>double</tt> in order to use its result, which is a step function, polymorphically. 
</p>
<h2 id="head-031723e7e62f3a194de0e2e7e9aa28cd46815d0f">Hiding the type of the accumulator</h2>
<p>
For clarity and to avoid mistakes, it can be useful to hide the type of the accumulator in a fold.  Reworking the simple variable-argument example to do this leads to the following. 
</p>

<pre class=code>
<B><FONT COLOR="#0000FF">structure</FONT></B> S:&gt;
  <B><FONT COLOR="#0000FF">sig</FONT></B>
     <B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ac
     </FONT></B><B><FONT COLOR="#A020F0">val</FONT></B> f: (ac, ac, unit, 'd) Fold.t
     <B><FONT COLOR="#A020F0">val</FONT></B> s: (ac, ac, 'b, 'c, 'd) Fold.step0
  <B><FONT COLOR="#0000FF">end</FONT></B> =
  <B><FONT COLOR="#0000FF">struct</FONT></B>
     <B><FONT COLOR="#A020F0">type</FONT></B><B><FONT COLOR="#228B22"> ac </FONT></B>=<B><FONT COLOR="#228B22"> unit
     </FONT></B><B><FONT COLOR="#A020F0">val</FONT></B> f = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.fold ((), <B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; ()) z
     <B><FONT COLOR="#A020F0">val</FONT></B> s = <B><FONT COLOR="#A020F0">fn</FONT></B> z =&gt; Fold.step0 (<B><FONT COLOR="#A020F0">fn</FONT></B> () =&gt; ()) z
  <B><FONT COLOR="#0000FF">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
The idea is to name the accumulator type and use opaque signature matching to make it abstract.  This can prevent improper manipulation of the accumulator by client code and ensure invariants that the folder and stepper would like to maintain. 
</p>
<p>
For a practical example of this technique, see <a href="ArrayLiteral">ArrayLiteral</a>. 
</p>
<h2 id="head-a4bc8bf5caf54b18cea9f58e83dd4acb488deb17">Also see</h2>
<p>
Fold has a number of practical applications.  Here are some of them. 
</p>

    <ul>

    <li>
<p>
 <a href="ArrayLiteral">ArrayLiteral</a> 
</p>
</li>
    <li>
<p>
 <a href="Fold01N">Fold01N</a> 
</p>
</li>
    <li>
<p>
 <a href="FunctionalRecordUpdate">FunctionalRecordUpdate</a> 
</p>
</li>
    <li>
<p>
 <a href="NumericLiteral">NumericLiteral</a> 
</p>
</li>
    <li>
<p>
 <a href="OptionalArguments">OptionalArguments</a> 
</p>
</li>
    <li>
<p>
 <a href="Printf">Printf</a> 
</p>
</li>
    <li>
<p>
 <a href="VariableArityPolymorphism">VariableArityPolymorphism</a> 
</p>
</li>

    </ul>


<p>
There are a number of related techniques.  Here are some of them. 
</p>

    <ul>

    <li>
<p>
 <a href="StaticSum">StaticSum</a> 
</p>
</li>
    <li>
<p>
 <a href="TypeIndexedValues">TypeIndexedValues</a> 
</p>
</li>
</ul>

</div>



<p>
<hr>
Last edited on 2009-06-10 19:19:58 by <span title="fenrir.uchicago.edu"><a href="MatthewFluet">MatthewFluet</a></span>.
</body></html>
